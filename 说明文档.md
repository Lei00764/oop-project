## 1. 题目

### 1.1 题目简介

题目是Windows版的Color linez游戏的简化版本。要求可以设置游戏的行列值，7个小问题层层递进，从在数组里实现在最终图形化界面。题目设置的具体游戏规则如下：初始状态有5个球，每移动一次球会随机产生3个不同颜色的球，球的颜色会提前进行预告，当同一颜色的球在横向、纵向达到5个及以上时，可以消除，同时得到相应的分数，假设消除n个球，此次得到的分数为(n-1) * (n-2)。

### 1.2 题目分析

首先要实现一个菜单函数，让用户通过菜单进行选择，从而执行相应的选项。选项1比较简单，选项2难点在于如何找到从起点到终点的路径，这里我采用的是深度优先搜索DFS+回溯的方法，选项3是一个完整的实现方案。选项4、5比较简单，主要是绘制伪图形界面，选项6难点在于阅读老师提供的两个代码文件，读懂获取鼠标坐标和鼠标点击等功能的实现方法。之前所采用的寻路算法移动过程比较慢，在选项7中，我实现了另一种寻路方法，广度优先搜索BFS，可以找到最优路径。

## 2. 整体设计思路

以选项7为例，需要完成的核心任务有通过鼠标选择正确的起始和目的坐标MouseAction、找到从起始到目的坐标的移动路径BFS、画出完整的移动路径DrawMove、计算本次移动得分IsDelete等。

针对整个程序，首先需要输入行列数，这里需要对错误输入进行处理，然后进行在数组中随机生成5个球，接着随机生成3个球，并记录这三个球在数组中的位置和颜色，页面显示题目要求的信息，

接着就是通过鼠标来选择正确的起始和目标坐标MouseAction，这是一个非常重要的函数，函数参数我特意设置成pre_line,  pre_col,  cur_line,  cur_col，而不是start_line,  start_col,  end_line,  end_col，这样做的好处是在循环执行MouseAction时，能比较清楚的知道此时变量值的含义。具体来说，首先调用cct_read_keyboard_and_mouse，获取当前鼠标的坐标，接着判断是否点击鼠标右键，如果是，直接退出；如果不是，判断是否点击鼠标左键，如果不是，直接退出，如果是，需要判断选中了球还是选中空白位置，分情况具体处理。

如果pre_line, pre_col是球的坐标，cur_line, cur_col是空白的坐标，此时需要执行DrawMove，DrawMove会首先执行BFS来寻找路径，如果没有路径，会有提示信息；如果存在路径，会画出完整的移动路径，移动完成后会计算本次移动得分。

接着会将之前记录的三个球花在原图形上，因为之前保存了位置和颜色信息，因此其实并不需要覆盖原来的图形界面。

所有上述步骤完成之后就完成了一次移动，之后需要判断游戏是否结束，具体来说：如果下一次移动数组中球的数量达到lines*cols，游戏失败；如果数组中球的数量等于0，游戏成功，当然这种情况是几乎不可能发生的。

## 3. 主要功能的实现

### 3.1 功能实现流程图：

### 3.2 寻路函数 DFS和BFS

BFS的算法思路：

1. 首先创建一个辅助二维数组，记录到某点的上一点的位置；

2. 维护一个队列，将起点添加到队列；

3. 设置起点的上一点位置为(-1, -1)；

4. 依次周围未被访问过的四个点，入队，并设置上一点的位置；

5. 重复步骤4直至队列为空；

6. 通过递归函数InsertPath得到从起点到终点的最短路径，存到Path数组中。

BFS算法：在向四周进行探索时，通过一个二维数组保存了到某点的前一点的信息，由于一个点的信息有行列两个数字，因此我定义了一个结构体Point，进而创建一个结构体二维数组来存储(line, col)(1 <= line <= lines, 1 <= col <= cols)前一点的信息。

在找到目标位置后，在新建的二维数组从后往前依次找到该点的前一位置，这样就可以的到最优的路径。

### 3.3 移动函数 DrawMove

针对DrawMove函数，我将移动过程分成了四个子函数，分别是MoveUp、MoveRight、MoveDown和MoveLeft，对应画出向上、右、下、左的动画过程。

每个子函数通过多次调用showstr来实现移动效果的绘制，通过增加延迟Sleep，让移动过程更加舒畅。

### 3.5 删除出连续球函数 IsDelete

针对IsDelete()函数，判断得分的规则主要由这个函数确定，在本题中，当同一颜色的球在横向、纵向达到5个及以上时，可以消除，同时得到相应的分数，假设消除n个球，此次得到的分数为 2 * n 。具体执行方法是，从目的位置出发，依次向上、右、下和左这四个方向试探，分别统计上下、左右的数量，如果上下或左右连续同颜色的球超过5个(包括5个)，记录删除的球的颜色和数量，并从数组中删除这些球，最后返回删除得分。

 

## 4. 调试过程碰到的问题

## 5. 完成本次作业心得体会

### 5.1 完成本次作业得到的一些心得体会、经验教训

1. 要注意变量的命名规则，这点主要体现在MouseAction函数，pre、cur和start、end的区别；

2. 多用const常量定义，最好在一开始就先整体分析一遍题目，看有哪些地方可能会需要，避免后面懒得改的情况；

3. 虽然我有一个函数只写了一行，但我觉得这个函数非常有用，这个函数是RecoverMark，让我不在需要判断在cmd上画图位置和数组位置的关系；

4. 在可以新建一个文件测试函数的正确性，比如我新建了一个文件专门测试DFS的正确性；

5. 尽量少用或不同全局变量，本题中要求不准用全局变量；

6. 写好函数的注视，包括参数的含义，函数的函数值，以及函数的作用等，好让自己和别人能够快速理解或使用这个函数；

7. 多写函数，控制一个函数中的代码长度，多通过函数嵌套来实现比较复杂的功能；

8. 程序出错，有可能不是编译器报错的地方出错，而是代码前面的代码有问题；

9. 代码写久了，遇到算法方面的问题，睡一觉吧，也许第二天问题可以轻松解决；

10. 对于递归函数，要从更高层面或者说直接思考函数的作用，而不是自己在脑中模拟递归函数的执行过程。

##  5.2 通过综合题1/2中有关函数的分解与使用，总结你在完成过程中是否考虑了前后小题的关联关系，是否能尽可能做到后面小题有效利用前面小题已完成的代码，如何才能更好地重用代码？

前6道小题我都考虑到了前后小题的关联关系，尽可能在做后面小题时直接调用前面已完成的代码(函数)。通过对一个函数增加一个参数choice就可以很好的在前面代码的基础之上进行新的功能。如几个比较主要的函数，DoByChoice45和DoByChoice67都是通过这种方式，当然对于选项1和选项2这种，我觉得没比较整合到一起。

但是在写完选项6，写选项7的时候，我感觉我MouseAction这一函数写的不好，没有考虑到循环调用，同时还发现自己之间没找到用户选择一个球以后选择另一个球的情况，最后我选择先写选项7，然后再选项6，虽然直接写选项7需要很长时间，但整体逻辑会清楚一点，而且写完选项7之后再写选项6就非常简单，加几行代码就好了。

为了能更好的重用代码，我觉得需要缩小函数的功能，多写几个函数，在写函数的时候，写好函数输入参数的含义、输出结果的含义以及函数的作用，方便自己之后调用函数。

总结：拿到一个项目，要先完整跑一边项目程序，明白每一步应该做什么，具体到每一个选项，这样可以对项目有一个大概的把握，从而能够更加合理地对函数进行划分，达到重用代码的目的。

 

 

​    

## 6. 源程序